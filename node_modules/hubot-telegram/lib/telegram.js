"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var hubot_1 = __importDefault(require("hubot"));
// This is for avoiding the wrong comparison of TextMessage prototype at receiving time
var TextMessage = require.main.require('hubot').TextMessage;
var node_telegram_bot_api_1 = __importDefault(require("node-telegram-bot-api"));
var telegrambot_1 = __importDefault(require("telegrambot"));
var TelegramMiddleware_1 = require("./TelegramMiddleware");
var TelegramAdapter = /** @class */ (function (_super) {
    __extends(TelegramAdapter, _super);
    function TelegramAdapter(robot) {
        var _this = _super.call(this, robot) || this;
        _this.createUser = function (user, chat) {
            var currentUser = new hubot_1.default.User(String(user.id), __assign(__assign({}, user), { name: user.username, room: chat === null || chat === void 0 ? void 0 : chat.id, telegram_chat: chat === null || chat === void 0 ? void 0 : chat.id }));
            return _this.robot.brain.userForId(String(user.id), currentUser);
        };
        _this.cleanMessageText = function (text, chat_id) {
            // If it is a private chat, automatically prepend the bot name if it does not exist already.
            if (chat_id > 0) {
                // Strip out the stuff we don't need.
                text = text.replace(/^\//g, '').trim();
                text = text.replace(new RegExp('^@?' + _this.robot.name, 'gi'), '');
                if (_this.robot.alias) {
                    text = text.replace(new RegExp('^@?' + _this.robot.alias, 'gi'), '');
                }
                text = _this.robot.name + ' ' + text.trim();
            }
            else {
                text = text.trim();
            }
            return text;
        };
        _this.robot = robot;
        _this.token = process.env['TELEGRAM_TOKEN'] || '';
        _this.interval = process.env['TELEGRAM_INTERVAL'] || '300';
        _this.webhook = process.env['TELEGRAM_WEBHOOK'] || '';
        _this.robot.logger.info("Telegram Adapter Bot " + _this.token + " Loaded...");
        _this.bot = new node_telegram_bot_api_1.default(_this.token, {
            polling: { autoStart: false, interval: _this.interval }
        });
        _this.handleUpdate = _this.handleUpdate.bind(_this);
        return _this;
    }
    TelegramAdapter.prototype.send = function (envelope) {
        var strings = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            strings[_i - 1] = arguments[_i];
        }
        this.bot.sendMessage(envelope.room, strings.join(), envelope.telegram);
    };
    TelegramAdapter.prototype.reply = function (envelope) {
        var strings = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            strings[_i - 1] = arguments[_i];
        }
        this.bot.sendMessage(envelope.room, strings.join(), __assign({ reply_to_message_id: Number(envelope.message.id) }, envelope.telegram));
    };
    TelegramAdapter.prototype.handleUpdate = function (message, metadata) {
        var _this = this;
        var _a;
        this.robot.logger.info("Received text message in channel: " + message.chat.id + ", from: " + ((_a = message.from) === null || _a === void 0 ? void 0 : _a.id));
        var messageId = String(message.message_id);
        // There are a few cases where `from` is not sent like channels
        var currentUser = message.from || {
            id: message.chat.id,
            is_bot: false,
            first_name: message.chat.first_name || String(message.chat.id)
        };
        var user = this.createUser(currentUser, message.chat);
        if (message.text) {
            this.robot.logger.debug("Received message: " + currentUser.id + " said '" + message.text + "'");
            var text = this.cleanMessageText(message.text, message.chat.id);
            this.receive(new TextMessage(user, text, messageId));
        }
        else if (message.new_chat_members) {
            // new_chat_members is an array of users
            message.new_chat_members.map(function (u) {
                var user = _this.createUser(u, message.chat);
                _this.robot.logger.info("User " + user.id + " joined chat " + message.chat.id);
                _this.receive(new hubot_1.default.EnterMessage(user, false));
            });
        }
        else if (message.left_chat_member) {
            var user_1 = this.createUser(message.left_chat_member, message.chat);
            this.robot.logger.info("User " + user_1.id + " left chat " + message.chat.id);
            this.receive(new hubot_1.default.LeaveMessage(user_1, false));
        }
        else if (message.new_chat_title) {
            this.robot.logger.info("User " + user.id + " changed chat " + message.chat.id + " title: " + message.new_chat_title);
            this.receive(new hubot_1.default.TopicMessage(user, message.new_chat_title, messageId));
        }
        else {
            var msg = new hubot_1.default.Message(user, false);
            this.receive(new hubot_1.default.CatchAllMessage(msg));
        }
    };
    TelegramAdapter.prototype.run = function () {
        var _this = this;
        if (!this.token) {
            this.emit('error', new Error('The environment variable "TELEGRAM_TOKEN" is required.'));
        }
        // Get the bot information
        this.bot
            .getMe()
            .then(function (user) {
            _this.robot.logger.info("Telegram Bot Identified: " + user.first_name);
            if (user.first_name !== _this.robot.name) {
                _this.robot.logger.warning('It is advised to use the same bot name as your Telegram Bot: ' +
                    user.username);
                _this.robot.logger.warning('Having a different bot name can result in an inconsistent experience when using @mentions');
            }
        })
            .catch(function (err) { return _this.emit('error', err); });
        if (this.webhook) {
            var endpoint = this.webhook + '/' + this.token;
            this.robot.logger.debug("Listening on " + endpoint);
            this.bot.setWebHook(endpoint).catch(function (err) { return _this.robot.emit('error', err); });
            this.robot.router.post("/" + this.token, function (req, res) {
                _this.bot.processUpdate(req.body);
                res.status(200).send({ ok: true });
            });
        }
        else {
            this.robot.logger.debug('Start polling APIs...');
            this.bot.startPolling();
        }
        // Listen for Telegram API invokes from other scripts
        this.robot.on('telegram:invoke', function (method, opts, cb) {
            var api = new telegrambot_1.default(_this.token);
            api.invoke(method, opts, cb);
        });
        // Exposing the telegram lib to the robot interface to support inlineQuery
        this.robot.telegram = this.bot;
        // Registering events
        this.bot.on('error', function (err) { return _this.emit('error', err); });
        this.bot.on('message', this.handleUpdate);
        this.bot.on('channel_post', this.handleUpdate);
        this.robot.logger.info('Telegram Adapter Started...');
        this.emit('connected');
    };
    return TelegramAdapter;
}(hubot_1.default.Adapter));
module.exports.use = function (robot) {
    var adapter = new TelegramAdapter(robot);
    robot.listenerMiddleware(TelegramMiddleware_1.telegramMiddleware(adapter));
    return adapter;
};
